"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _synchronousPromise = require("synchronous-promise");

var _Cancel = _interopRequireDefault(require("./cancel/Cancel"));

var _CancelToken = _interopRequireDefault(require("./cancel/CancelToken"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** a FIFO queue of pending request */
var _pending_requests = [];

var _newReq = function _newReq() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var actualConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof config === 'string') {
    // Allow for axios('example/url'[, config])
    actualConfig.url = config;
    config = actualConfig;
  }

  var method = config.method || "get";
  var url = config.url;
  var data = config.data;

  var promise = _synchronousPromise.SynchronousPromise.unresolved();

  if (config.cancelToken) {
    config.cancelToken.promise.then(function (cancel) {
      // check if promise is still waiting for an answer
      if (_pending_requests.find(function (x) {
        return x.promise === promise;
      })) {
        MockAxios.mockError(cancel, promise);
      }
    });
  }

  _pending_requests.push({
    config: config,
    data: data,
    method: method,
    promise: promise,
    url: url
  });

  return promise;
};

var _helperReq = function _helperReq(method, url, data, config) {
  var conf = data && config ? config : {};
  return _newReq(_objectSpread(_objectSpread({}, conf), {}, {
    data: data,
    method: method,
    url: url
  }));
};

var _helperReqNoData = function _helperReqNoData(method, url, config) {
  return _helperReq(method, url, {}, config);
};

var MockAxios = jest.fn(_newReq); // mocking Axios methods

MockAxios.get = jest.fn(_helperReqNoData.bind(null, "get"));
MockAxios.post = jest.fn(_helperReq.bind(null, "post"));
MockAxios.put = jest.fn(_helperReq.bind(null, "put"));
MockAxios.patch = jest.fn(_helperReq.bind(null, "patch"));
MockAxios["delete"] = jest.fn(_helperReqNoData.bind(null, "delete"));
MockAxios.request = jest.fn(_newReq);
MockAxios.all = jest.fn(function (values) {
  return Promise.all(values);
});
MockAxios.head = jest.fn(_helperReqNoData.bind(null, "head"));
MockAxios.options = jest.fn(_helperReqNoData.bind(null, "options"));
MockAxios.create = jest.fn(function () {
  return MockAxios;
});
MockAxios.interceptors = {
  request: {
    use: jest.fn(),
    eject: jest.fn()
  },
  response: {
    use: jest.fn(),
    eject: jest.fn()
  }
};
MockAxios.defaults = {
  headers: {
    common: []
  }
};

MockAxios.popPromise = function (promise) {
  if (promise) {
    // remove the promise from pending queue
    for (var ix = 0; ix < _pending_requests.length; ix++) {
      var req = _pending_requests[ix];

      if (req.promise === promise) {
        _pending_requests.splice(ix, 1);

        return req.promise;
      }
    }
  } else {
    // take the oldest promise
    var _req = _pending_requests.shift();

    return _req ? _req.promise : void 0;
  }
};

MockAxios.popRequest = function (request) {
  if (request) {
    var ix = _pending_requests.indexOf(request);

    if (ix === -1) {
      return void 0;
    }

    _pending_requests.splice(ix, 1);

    return request;
  } else {
    return _pending_requests.shift();
  }
};
/**
 * Removes an item form the queue, based on it's type
 * @param queueItem
 */


var popQueueItem = function popQueueItem() {
  var queueItem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  // first let's pretend the param is a queue item
  var request = MockAxios.popRequest(queueItem);

  if (request) {
    // IF the request was found
    // > set the promise
    return request.promise;
  } else {
    // ELSE maybe the `queueItem` is a promise (legacy mode)
    return MockAxios.popPromise(queueItem);
  }
};

MockAxios.mockResponse = function (response) {
  var queueItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var silentMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // replacing missing data with default values
  response = Object.assign({
    config: {},
    data: {},
    headers: {},
    status: 200,
    statusText: "OK"
  }, response);
  var promise = popQueueItem(queueItem);

  if (!promise && !silentMode) {
    throw new Error("No request to respond to!");
  } else if (!promise) {
    return;
  } // resolving the Promise with the given response data


  promise.resolve(response);
};

MockAxios.mockResponseFor = function (criteria, response) {
  var silentMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (typeof criteria === "string") {
    criteria = {
      url: criteria
    };
  }

  var queueItem = MockAxios.getReqMatching(criteria);

  if (!queueItem && !silentMode) {
    throw new Error("No request to respond to!");
  } else if (!queueItem) {
    return;
  }

  MockAxios.mockResponse(response, queueItem, silentMode);
};

MockAxios.mockError = function () {
  var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var queueItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var silentMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var promise = popQueueItem(queueItem);

  if (!promise && !silentMode) {
    throw new Error("No request to respond to!");
  } else if (!promise) {
    return;
  }

  if (error && _typeof(error) === 'object' && error.isAxiosError === void 0) {
    error.isAxiosError = true;
  } // resolving the Promise with the given error


  promise.reject(error);
};

MockAxios.isAxiosError = function (payload) {
  return _typeof(payload) === 'object' && payload.isAxiosError === true;
};

MockAxios.lastReqGet = function () {
  return _pending_requests[_pending_requests.length - 1];
};

MockAxios.lastPromiseGet = function () {
  var req = MockAxios.lastReqGet();
  return req ? req.promise : void 0;
};

var _findReqByPredicate = function _findReqByPredicate(predicate) {
  return _pending_requests.slice().reverse() // reverse cloned array to return most recent req
  .find(predicate);
};

var _checkCriteria = function _checkCriteria(item, criteria) {
  if (criteria.method !== undefined && criteria.method.toLowerCase() !== item.method.toLowerCase()) {
    return false;
  }

  if (criteria.url !== undefined && criteria.url !== item.url) {
    return false;
  }

  return true;
};

MockAxios.getReqMatching = function (criteria) {
  return _findReqByPredicate(function (x) {
    return _checkCriteria(x, criteria);
  });
};

MockAxios.getReqByUrl = function (url) {
  return MockAxios.getReqMatching({
    url: url
  });
};

MockAxios.getReqByMatchUrl = function (url) {
  return _findReqByPredicate(function (x) {
    return url.test(x.url);
  });
};

MockAxios.getReqByRegex = function (opts) {
  return _findReqByPredicate(function (x) {
    return Object.entries(opts).every(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];

      return value.test(JSON.stringify(x[key]));
    });
  });
};

MockAxios.queue = function () {
  return _pending_requests;
};

MockAxios.reset = function () {
  // remove all the requests
  _pending_requests.splice(0, _pending_requests.length); // resets all information stored in the mockFn.mock.calls and mockFn.mock.instances arrays


  MockAxios.get.mockClear();
  MockAxios.post.mockClear();
  MockAxios.put.mockClear();
  MockAxios.patch.mockClear();
  MockAxios["delete"].mockClear();
  MockAxios.head.mockClear();
  MockAxios.options.mockClear();
  MockAxios.request.mockClear();
  MockAxios.all.mockClear();
};

MockAxios.Cancel = _Cancel["default"];
MockAxios.CancelToken = _CancelToken["default"];

MockAxios.isCancel = function (u) {
  return !!(u && u.__CANCEL__);
}; // this is a singleton object


var _default = MockAxios;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2xpYi9tb2NrLWF4aW9zLnRzIl0sIm5hbWVzIjpbIl9wZW5kaW5nX3JlcXVlc3RzIiwiX25ld1JlcSIsImNvbmZpZyIsImFjdHVhbENvbmZpZyIsInVybCIsIm1ldGhvZCIsImRhdGEiLCJwcm9taXNlIiwiU3luY2hyb25vdXNQcm9taXNlIiwidW5yZXNvbHZlZCIsImNhbmNlbFRva2VuIiwidGhlbiIsImNhbmNlbCIsImZpbmQiLCJ4IiwiTW9ja0F4aW9zIiwibW9ja0Vycm9yIiwicHVzaCIsIl9oZWxwZXJSZXEiLCJjb25mIiwiX2hlbHBlclJlcU5vRGF0YSIsImplc3QiLCJmbiIsImdldCIsImJpbmQiLCJwb3N0IiwicHV0IiwicGF0Y2giLCJyZXF1ZXN0IiwiYWxsIiwidmFsdWVzIiwiUHJvbWlzZSIsImhlYWQiLCJvcHRpb25zIiwiY3JlYXRlIiwiaW50ZXJjZXB0b3JzIiwidXNlIiwiZWplY3QiLCJyZXNwb25zZSIsImRlZmF1bHRzIiwiaGVhZGVycyIsImNvbW1vbiIsInBvcFByb21pc2UiLCJpeCIsImxlbmd0aCIsInJlcSIsInNwbGljZSIsInNoaWZ0IiwicG9wUmVxdWVzdCIsImluZGV4T2YiLCJwb3BRdWV1ZUl0ZW0iLCJxdWV1ZUl0ZW0iLCJtb2NrUmVzcG9uc2UiLCJzaWxlbnRNb2RlIiwiT2JqZWN0IiwiYXNzaWduIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsIkVycm9yIiwicmVzb2x2ZSIsIm1vY2tSZXNwb25zZUZvciIsImNyaXRlcmlhIiwiZ2V0UmVxTWF0Y2hpbmciLCJlcnJvciIsImlzQXhpb3NFcnJvciIsInJlamVjdCIsInBheWxvYWQiLCJsYXN0UmVxR2V0IiwibGFzdFByb21pc2VHZXQiLCJfZmluZFJlcUJ5UHJlZGljYXRlIiwicHJlZGljYXRlIiwic2xpY2UiLCJyZXZlcnNlIiwiX2NoZWNrQ3JpdGVyaWEiLCJpdGVtIiwidW5kZWZpbmVkIiwidG9Mb3dlckNhc2UiLCJnZXRSZXFCeVVybCIsImdldFJlcUJ5TWF0Y2hVcmwiLCJ0ZXN0IiwiZ2V0UmVxQnlSZWdleCIsIm9wdHMiLCJlbnRyaWVzIiwiZXZlcnkiLCJrZXkiLCJ2YWx1ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJxdWV1ZSIsInJlc2V0IiwibW9ja0NsZWFyIiwiQ2FuY2VsIiwiQ2FuY2VsVG9rZW4iLCJpc0NhbmNlbCIsInUiLCJfX0NBTkNFTF9fIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBUUE7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVFBO0FBQ0EsSUFBTUEsaUJBQXVDLEdBQUcsRUFBaEQ7O0FBRUEsSUFBTUMsT0FBNEQsR0FBRyxTQUEvREEsT0FBK0QsR0FBOEM7QUFBQSxNQUE3Q0MsTUFBNkMsdUVBQS9CLEVBQStCO0FBQUEsTUFBM0JDLFlBQTJCLHVFQUFQLEVBQU87O0FBQy9HLE1BQUcsT0FBT0QsTUFBUCxLQUFrQixRQUFyQixFQUErQjtBQUMzQjtBQUNBQyxJQUFBQSxZQUFZLENBQUNDLEdBQWIsR0FBbUJGLE1BQW5CO0FBQ0FBLElBQUFBLE1BQU0sR0FBR0MsWUFBVDtBQUNIOztBQUVELE1BQU1FLE1BQWMsR0FBR0gsTUFBTSxDQUFDRyxNQUFQLElBQWlCLEtBQXhDO0FBQ0EsTUFBTUQsR0FBVyxHQUFHRixNQUFNLENBQUNFLEdBQTNCO0FBQ0EsTUFBTUUsSUFBUyxHQUFHSixNQUFNLENBQUNJLElBQXpCOztBQUNBLE1BQU1DLE9BQTBDLEdBQUdDLHVDQUFtQkMsVUFBbkIsRUFBbkQ7O0FBRUEsTUFBR1AsTUFBTSxDQUFDUSxXQUFWLEVBQXVCO0FBQ25CUixJQUFBQSxNQUFNLENBQUNRLFdBQVAsQ0FBbUJILE9BQW5CLENBQTJCSSxJQUEzQixDQUFnQyxVQUFDQyxNQUFELEVBQWlCO0FBQzdDO0FBQ0EsVUFBR1osaUJBQWlCLENBQUNhLElBQWxCLENBQXVCLFVBQUFDLENBQUM7QUFBQSxlQUFJQSxDQUFDLENBQUNQLE9BQUYsS0FBY0EsT0FBbEI7QUFBQSxPQUF4QixDQUFILEVBQXVEO0FBQ25EUSxRQUFBQSxTQUFTLENB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RUEsQ0FBQyxJQUFJQSxDQUFDLENBQUNDLFVBQVQsQ0FBUjtBQUNILENBRkQsQyxDQUlBOzs7ZUFDZWhGLFMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFR5cGVTY3JpcHQgdmVyc2lvbiBvZiBBeGlvcyBtb2NrIGZvciB1bml0IHRlc3Rpbmcgd2l0aCBbSmVzdF0oaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8pLlxuICogVGhpcyBmaWxlIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3R1eDQvMzYwMDZhMTg1OTMyM2Y3NzlhYjBcbiAqXG4gKiBAYXV0aG9yICAga25lZS1jb2xhIDxuaWtvbGEuZGVyZXppY0BnbWFpbC5jb20+XG4gKiBAbGljZW5zZSAgQGxpY2Vuc2UgTUlUIExpY2Vuc2UsIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cblxuaW1wb3J0IHsgU3luY2hyb25vdXNQcm9taXNlLCBVbnJlc29sdmVkU3luY2hyb25vdXNQcm9taXNlIH0gZnJvbSBcInN5bmNocm9ub3VzLXByb21pc2VcIjtcbmltcG9ydCBDYW5jZWwgZnJvbSBcIi4vY2FuY2VsL0NhbmNlbFwiO1xuaW1wb3J0IENhbmNlbFRva2VuIGZyb20gXCIuL2NhbmNlbC9DYW5jZWxUb2tlblwiO1xuaW1wb3J0IHtcbiAgICBBeGlvc01vY2tRdWV1ZUl0ZW0sXG4gICAgQXhpb3NNb2NrUmVxdWVzdENyaXRlcmlhLFxuICAgIEF4aW9zTW9ja1R5cGUsXG4gICAgSHR0cFJlc3BvbnNlLFxufSBmcm9tIFwiLi9tb2NrLWF4aW9zLXR5cGVzXCI7XG5cbi8qKiBhIEZJRk8gcXVldWUgb2YgcGVuZGluZyByZXF1ZXN0ICovXG5jb25zdCBfcGVuZGluZ19yZXF1ZXN0czogQXhpb3NNb2NrUXVldWVJdGVtW10gPSBbXTtcblxuY29uc3QgX25ld1JlcTogKGNvbmZpZz86IGFueSkgPT4gVW5yZXNvbHZlZFN5bmNocm9ub3VzUHJvbWlzZTxhbnk+ID0gKGNvbmZpZzogYW55ID0ge30sIGFjdHVhbENvbmZpZzogYW55ID0ge30pID0+IHtcbiAgICBpZih0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pXG4gICAgICAgIGFjdHVhbENvbmZpZy51cmwgPSBjb25maWc7XG4gICAgICAgIGNvbmZpZyA9IGFjdHVhbENvbmZpZztcbiAgICB9XG5cbiAgICBjb25zdCBtZXRob2Q6IHN0cmluZyA9IGNvbmZpZy5tZXRob2QgfHwgXCJnZXRcIjtcbiAgICBjb25zdCB1cmw6IHN0cmluZyA9IGNvbmZpZy51cmw7XG4gICAgY29uc3QgZGF0YTogYW55ID0gY29uZmlnLmRhdGE7XG4gICAgY29uc3QgcHJvbWlzZTogVW5yZXNvbHZlZFN5bmNocm9ub3VzUHJvbWlzZTxhbnk+ID0gU3luY2hyb25vdXNQcm9taXNlLnVucmVzb2x2ZWQoKTtcblxuICAgIGlmKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKChjYW5jZWw6IGFueSkgPT4ge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgcHJvbWlzZSBpcyBzdGlsbCB3YWl0aW5nIGZvciBhbiBhbnN3ZXJcbiAgICAgICAgICAgIGlmKF9wZW5kaW5nX3JlcXVlc3RzLmZpbmQoeCA9PiB4LnByb21pc2UgPT09IHByb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgTW9ja0F4aW9zLm1vY2tFcnJvcihjYW5jZWwsIHByb21pc2UpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgX3BlbmRpbmdfcmVxdWVzdHMucHVzaCh7XG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBwcm9taXNlLFxuICAgICAgICB1cmxcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbmNvbnN0IF9oZWxwZXJSZXEgPSAobWV0aG9kOiBzdHJpbmcsIHVybDogc3RyaW5nLCBkYXRhPzogYW55LCBjb25maWc/OiBhbnkpID0+IHtcbiAgICBjb25zdCBjb25mID0gZGF0YSAmJiBjb25maWcgPyBjb25maWcgOiB7fTtcbiAgICByZXR1cm4gX25ld1JlcSh7XG4gICAgICAgIC4uLmNvbmYsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgdXJsLFxuICAgIH0pO1xufTtcblxuY29uc3QgX2hlbHBlclJlcU5vRGF0YSA9IChtZXRob2Q6IHN0cmluZywgdXJsOiBzdHJpbmcsIGNvbmZpZz86IGFueSkgPT4ge1xuICAgIHJldHVybiBfaGVscGVyUmVxKG1ldGhvZCwgdXJsLCB7fSwgY29uZmlnKVxufVxuXG5jb25zdCBNb2NrQXhpb3M6IEF4aW9zTW9ja1R5cGUgPSAoamVzdC5mbihfbmV3UmVxKSBhcyB1bmtub3duKSBhcyBBeGlvc01vY2tUeXBlO1xuXG4vLyBtb2NraW5nIEF4aW9zIG1ldGhvZHNcbk1vY2tBeGlvcy5nZXQgPSBqZXN0LmZuKF9oZWxwZXJSZXFOb0RhdGEuYmluZChudWxsLCBcImdldFwiKSk7XG5Nb2NrQXhpb3MucG9zdCA9IGplc3QuZm4oX2hlbHBlclJlcS5iaW5kKG51bGwsIFwicG9zdFwiKSk7XG5Nb2NrQXhpb3MucHV0ID0gamVzdC5mbihfaGVscGVyUmVxLmJpbmQobnVsbCwgXCJwdXRcIikpO1xuTW9ja0F4aW9zLnBhdGNoID0gamVzdC5mbihfaGVscGVyUmVxLmJpbmQobnVsbCwgXCJwYXRjaFwiKSk7XG5Nb2NrQXhpb3MuZGVsZXRlID0gamVzdC5mbihfaGVscGVyUmVxTm9EYXRhLmJpbmQobnVsbCwgXCJkZWxldGVcIikpO1xuTW9ja0F4aW9zLnJlcXVlc3QgPSBqZXN0LmZuKF9uZXdSZXEpO1xuTW9ja0F4aW9zLmFsbCA9IGplc3QuZm4oKHZhbHVlcykgPT4gUHJvbWlzZS5hbGwodmFsdWVzKSk7XG5Nb2NrQXhpb3MuaGVhZCA9IGplc3QuZm4oX2hlbHBlclJlcU5vRGF0YS5iaW5kKG51bGwsIFwiaGVhZFwiKSk7XG5Nb2NrQXhpb3Mub3B0aW9ucyA9IGplc3QuZm4oX2hlbHBlclJlcU5vRGF0YS5iaW5kKG51bGwsIFwib3B0aW9uc1wiKSk7XG5Nb2NrQXhpb3MuY3JlYXRlID0gamVzdC5mbigoKSA9PiBNb2NrQXhpb3MpO1xuXG5Nb2NrQXhpb3MuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgdXNlOiBqZXN0LmZuKCksXG4gICAgICAgIGVqZWN0OiBqZXN0LmZuKCksXG4gICAgfSxcbiAgICByZXNwb25zZToge1xuICAgICAgICB1c2U6IGplc3QuZm4oKSxcbiAgICAgICAgZWplY3Q6IGplc3QuZm4oKSxcbiAgICB9LFxufTtcblxuTW9ja0F4aW9zLmRlZmF1bHRzID0ge1xuICAgIGhlYWRlcnM6IHtcbiAgICAgICAgY29tbW9uOiBbXSxcbiAgICB9LFxufTtcblxuTW9ja0F4aW9zLnBvcFByb21pc2UgPSAocHJvbWlzZT86IFN5bmNocm9ub3VzUHJvbWlzZTxhbnk+KSA9PiB7XG4gICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBwcm9taXNlIGZyb20gcGVuZGluZyBxdWV1ZVxuICAgICAgICBmb3IgKGxldCBpeCA9IDA7IGl4IDwgX3BlbmRpbmdfcmVxdWVzdHMubGVuZ3RoOyBpeCsrKSB7XG4gICAgICAgICAgICBjb25zdCByZXE6IEF4aW9zTW9ja1F1ZXVlSXRlbSA9IF9wZW5kaW5nX3JlcXVlc3RzW2l4XTtcblxuICAgICAgICAgICAgaWYgKHJlcS5wcm9taXNlID09PSBwcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgX3BlbmRpbmdfcmVxdWVzdHMuc3BsaWNlKGl4LCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxLnByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0YWtlIHRoZSBvbGRlc3QgcHJvbWlzZVxuICAgICAgICBjb25zdCByZXE6IEF4aW9zTW9ja1F1ZXVlSXRlbSA9IF9wZW5kaW5nX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiByZXEgPyByZXEucHJvbWlzZSA6IHZvaWQgMDtcbiAgICB9XG59O1xuXG5Nb2NrQXhpb3MucG9wUmVxdWVzdCA9IChyZXF1ZXN0PzogQXhpb3NNb2NrUXVldWVJdGVtKSA9PiB7XG4gICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgaXggPSBfcGVuZGluZ19yZXF1ZXN0cy5pbmRleE9mKHJlcXVlc3QpO1xuICAgICAgICBpZiAoaXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgX3BlbmRpbmdfcmVxdWVzdHMuc3BsaWNlKGl4LCAxKTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9wZW5kaW5nX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIGl0ZW0gZm9ybSB0aGUgcXVldWUsIGJhc2VkIG9uIGl0J3MgdHlwZVxuICogQHBhcmFtIHF1ZXVlSXRlbVxuICovXG5jb25zdCBwb3BRdWV1ZUl0ZW0gPSAocXVldWVJdGVtOiBTeW5jaHJvbm91c1Byb21pc2U8YW55PiB8IEF4aW9zTW9ja1F1ZXVlSXRlbSA9IG51bGwpID0+IHtcbiAgICAvLyBmaXJzdCBsZXQncyBwcmV0ZW5kIHRoZSBwYXJhbSBpcyBhIHF1ZXVlIGl0ZW1cbiAgICBjb25zdCByZXF1ZXN0OiBBeGlvc01vY2tRdWV1ZUl0ZW0gPSBNb2NrQXhpb3MucG9wUmVxdWVzdChcbiAgICAgICAgcXVldWVJdGVtIGFzIEF4aW9zTW9ja1F1ZXVlSXRlbSxcbiAgICApO1xuXG4gICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgLy8gSUYgdGhlIHJlcXVlc3Qgd2FzIGZvdW5kXG4gICAgICAgIC8vID4gc2V0IHRoZSBwcm9taXNlXG4gICAgICAgIHJldHVybiByZXF1ZXN0LnByb21pc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRUxTRSBtYXliZSB0aGUgYHF1ZXVlSXRlbWAgaXMgYSBwcm9taXNlIChsZWdhY3kgbW9kZSlcbiAgICAgICAgcmV0dXJuIE1vY2tBeGlvcy5wb3BQcm9taXNlKHF1ZXVlSXRlbSBhcyBVbnJlc29sdmVkU3luY2hyb25vdXNQcm9taXNlPGFueT4pO1xuICAgIH1cbn07XG5cbk1vY2tBeGlvcy5tb2NrUmVzcG9uc2UgPSAoXG4gICAgcmVzcG9uc2U/OiBIdHRwUmVzcG9uc2UsXG4gICAgcXVldWVJdGVtOiBTeW5jaHJvbm91c1Byb21pc2U8YW55PiB8IEF4aW9zTW9ja1F1ZXVlSXRlbSA9IG51bGwsXG4gICAgc2lsZW50TW9kZTogYm9vbGVhbiA9IGZhbHNlLFxuKTogdm9pZCA9PiB7XG4gICAgLy8gcmVwbGFjaW5nIG1pc3NpbmcgZGF0YSB3aXRoIGRlZmF1bHQgdmFsdWVzXG4gICAgcmVzcG9uc2UgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICB7XG4gICAgICAgICAgICBjb25maWc6IHt9LFxuICAgICAgICAgICAgZGF0YToge30sXG4gICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogXCJPS1wiLFxuICAgICAgICB9LFxuICAgICAgICByZXNwb25zZSxcbiAgICApO1xuXG4gICAgY29uc3QgcHJvbWlzZSA9IHBvcFF1ZXVlSXRlbShxdWV1ZUl0ZW0pO1xuXG4gICAgaWYgKCFwcm9taXNlICYmICFzaWxlbnRNb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlcXVlc3QgdG8gcmVzcG9uZCB0byFcIik7XG4gICAgfSBlbHNlIGlmICghcHJvbWlzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2aW5nIHRoZSBQcm9taXNlIHdpdGggdGhlIGdpdmVuIHJlc3BvbnNlIGRhdGFcbiAgICBwcm9taXNlLnJlc29sdmUocmVzcG9uc2UpO1xufTtcblxuTW9ja0F4aW9zLm1vY2tSZXNwb25zZUZvciA9IChcbiAgICBjcml0ZXJpYTogc3RyaW5nIHwgQXhpb3NNb2NrUmVxdWVzdENyaXRlcmlhLFxuICAgIHJlc3BvbnNlPzogSHR0cFJlc3BvbnNlLFxuICAgIHNpbGVudE1vZGU6IGJvb2xlYW4gPSBmYWxzZSxcbik6IHZvaWQgPT4ge1xuICAgIGlmICh0eXBlb2YgY3JpdGVyaWEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY3JpdGVyaWEgPSB7dXJsOiBjcml0ZXJpYX07XG4gICAgfVxuICAgIGNvbnN0IHF1ZXVlSXRlbSA9IE1vY2tBeGlvcy5nZXRSZXFNYXRjaGluZyhjcml0ZXJpYSk7XG5cbiAgICBpZiAoIXF1ZXVlSXRlbSAmJiAhc2lsZW50TW9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXF1ZXN0IHRvIHJlc3BvbmQgdG8hXCIpO1xuICAgIH0gZWxzZSBpZiAoIXF1ZXVlSXRlbSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgTW9ja0F4aW9zLm1vY2tSZXNwb25zZShyZXNwb25zZSwgcXVldWVJdGVtLCBzaWxlbnRNb2RlKTtcbn07XG5cbk1vY2tBeGlvcy5tb2NrRXJyb3IgPSAoXG4gICAgZXJyb3I6IGFueSA9IHt9LFxuICAgIHF1ZXVlSXRlbTogU3luY2hyb25vdXNQcm9taXNlPGFueT4gfCBBeGlvc01vY2tRdWV1ZUl0ZW0gPSBudWxsLFxuICAgIHNpbGVudE1vZGU6IGJvb2xlYW4gPSBmYWxzZSxcbikgPT4ge1xuICAgIGNvbnN0IHByb21pc2UgPSBwb3BRdWV1ZUl0ZW0ocXVldWVJdGVtKTtcblxuICAgIGlmICghcHJvbWlzZSAmJiAhc2lsZW50TW9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXF1ZXN0IHRvIHJlc3BvbmQgdG8hXCIpO1xuICAgIH0gZWxzZSBpZiAoIXByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yLmlzQXhpb3NFcnJvciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGVycm9yLmlzQXhpb3NFcnJvciA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2aW5nIHRoZSBQcm9taXNlIHdpdGggdGhlIGdpdmVuIGVycm9yXG4gICAgcHJvbWlzZS5yZWplY3QoZXJyb3IpO1xufTtcblxuTW9ja0F4aW9zLmlzQXhpb3NFcnJvciA9IChwYXlsb2FkKSA9PiAodHlwZW9mIHBheWxvYWQgPT09ICdvYmplY3QnKSAmJiAocGF5bG9hZC5pc0F4aW9zRXJyb3IgPT09IHRydWUpO1xuXG5Nb2NrQXhpb3MubGFzdFJlcUdldCA9ICgpID0+IHtcbiAgICByZXR1cm4gX3BlbmRpbmdfcmVxdWVzdHNbX3BlbmRpbmdfcmVxdWVzdHMubGVuZ3RoIC0gMV07XG59O1xuXG5Nb2NrQXhpb3MubGFzdFByb21pc2VHZXQgPSAoKSA9PiB7XG4gICAgY29uc3QgcmVxID0gTW9ja0F4aW9zLmxhc3RSZXFHZXQoKTtcbiAgICByZXR1cm4gcmVxID8gcmVxLnByb21pc2UgOiB2b2lkIDA7XG59O1xuXG5jb25zdCBfZmluZFJlcUJ5UHJlZGljYXRlID0gKHByZWRpY2F0ZTogKGl0ZW06IEF4aW9zTW9ja1F1ZXVlSXRlbSkgPT4gYm9vbGVhbikgPT4ge1xuICAgIHJldHVybiBfcGVuZGluZ19yZXF1ZXN0c1xuICAgIC5zbGljZSgpXG4gICAgLnJldmVyc2UoKSAvLyByZXZlcnNlIGNsb25lZCBhcnJheSB0byByZXR1cm4gbW9zdCByZWNlbnQgcmVxXG4gICAgLmZpbmQocHJlZGljYXRlKTtcbn1cblxuY29uc3QgX2NoZWNrQ3JpdGVyaWEgPSAoaXRlbTogQXhpb3NNb2NrUXVldWVJdGVtLCBjcml0ZXJpYTogQXhpb3NNb2NrUmVxdWVzdENyaXRlcmlhKSA9PiB7XG4gICAgaWYgKGNyaXRlcmlhLm1ldGhvZCAhPT0gdW5kZWZpbmVkICYmIGNyaXRlcmlhLm1ldGhvZC50b0xvd2VyQ2FzZSgpICE9PSBpdGVtLm1ldGhvZC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoY3JpdGVyaWEudXJsICE9PSB1bmRlZmluZWQgJiYgY3JpdGVyaWEudXJsICE9PSBpdGVtLnVybCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Nb2NrQXhpb3MuZ2V0UmVxTWF0Y2hpbmcgPSAoY3JpdGVyaWE6IEF4aW9zTW9ja1JlcXVlc3RDcml0ZXJpYSkgPT4ge1xuICAgIHJldHVybiBfZmluZFJlcUJ5UHJlZGljYXRlKCh4KSA9PiBfY2hlY2tDcml0ZXJpYSh4LCBjcml0ZXJpYSkpO1xufTtcblxuTW9ja0F4aW9zLmdldFJlcUJ5VXJsID0gKHVybDogc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIE1vY2tBeGlvcy5nZXRSZXFNYXRjaGluZyh7dXJsfSk7XG59O1xuXG5Nb2NrQXhpb3MuZ2V0UmVxQnlNYXRjaFVybCA9ICh1cmw6IFJlZ0V4cCkgPT4ge1xuICAgIHJldHVybiBfZmluZFJlcUJ5UHJlZGljYXRlKCh4KSA9PiB1cmwudGVzdCh4LnVybCkpO1xufTtcblxuTW9ja0F4aW9zLmdldFJlcUJ5UmVnZXggPSAob3B0czoge1trZXkgaW4ga2V5b2YgQXhpb3NNb2NrUXVldWVJdGVtXSs/OiBSZWdFeHB9KSA9PiB7XG4gIHJldHVybiBfZmluZFJlcUJ5UHJlZGljYXRlKHggPT4gT2JqZWN0LmVudHJpZXMob3B0cykuZXZlcnkoKFtrZXksIHZhbHVlXSkgPT4gdmFsdWUudGVzdChKU09OLnN0cmluZ2lmeSh4W2tleV0pKSkpO1xufTtcblxuTW9ja0F4aW9zLnF1ZXVlID0gKCkgPT4ge1xuICAgIHJldHVybiBfcGVuZGluZ19yZXF1ZXN0cztcbn07XG5cbk1vY2tBeGlvcy5yZXNldCA9ICgpID0+IHtcbiAgICAvLyByZW1vdmUgYWxsIHRoZSByZXF1ZXN0c1xuICAgIF9wZW5kaW5nX3JlcXVlc3RzLnNwbGljZSgwLCBfcGVuZGluZ19yZXF1ZXN0cy5sZW5ndGgpO1xuXG4gICAgLy8gcmVzZXRzIGFsbCBpbmZvcm1hdGlvbiBzdG9yZWQgaW4gdGhlIG1vY2tGbi5tb2NrLmNhbGxzIGFuZCBtb2NrRm4ubW9jay5pbnN0YW5jZXMgYXJyYXlzXG4gICAgTW9ja0F4aW9zLmdldC5tb2NrQ2xlYXIoKTtcbiAgICBNb2NrQXhpb3MucG9zdC5tb2NrQ2xlYXIoKTtcbiAgICBNb2NrQXhpb3MucHV0Lm1vY2tDbGVhcigpO1xuICAgIE1vY2tBeGlvcy5wYXRjaC5tb2NrQ2xlYXIoKTtcbiAgICBNb2NrQXhpb3MuZGVsZXRlLm1vY2tDbGVhcigpO1xuICAgIE1vY2tBeGlvcy5oZWFkLm1vY2tDbGVhcigpO1xuICAgIE1vY2tBeGlvcy5vcHRpb25zLm1vY2tDbGVhcigpO1xuICAgIE1vY2tBeGlvcy5yZXF1ZXN0Lm1vY2tDbGVhcigpO1xuICAgIE1vY2tBeGlvcy5hbGwubW9ja0NsZWFyKCk7XG59O1xuXG5Nb2NrQXhpb3MuQ2FuY2VsID0gQ2FuY2VsO1xuTW9ja0F4aW9zLkNhbmNlbFRva2VuID0gQ2FuY2VsVG9rZW47XG5Nb2NrQXhpb3MuaXNDYW5jZWwgPSAodSk6IHUgaXMgQ2FuY2VsID0+IHtcbiAgICByZXR1cm4gISEodSAmJiB1Ll9fQ0FOQ0VMX18pO1xufTtcblxuLy8gdGhpcyBpcyBhIHNpbmdsZXRvbiBvYmplY3RcbmV4cG9ydCBkZWZhdWx0IE1vY2tBeGlvcztcbiJdfQ==