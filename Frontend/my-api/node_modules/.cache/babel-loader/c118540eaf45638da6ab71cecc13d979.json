{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bufferTime = void 0;\n\nvar Subscription_1 = require(\"../Subscription\");\n\nvar lift_1 = require(\"../util/lift\");\n\nvar OperatorSubscriber_1 = require(\"./OperatorSubscriber\");\n\nvar arrRemove_1 = require(\"../util/arrRemove\");\n\nvar async_1 = require(\"../scheduler/async\");\n\nvar args_1 = require(\"../util/args\");\n\nvar executeSchedule_1 = require(\"../util/executeSchedule\");\n\nfunction bufferTime(bufferTimeSpan) {\n  var _a, _b;\n\n  var otherArgs = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    otherArgs[_i - 1] = arguments[_i];\n  }\n\n  var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;\n  var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;\n  var maxBufferSize = otherArgs[1] || Infinity;\n  return lift_1.operate(function (source, subscriber) {\n    var bufferRecords = [];\n    var restartOnEmit = false;\n\n    var emit = function (record) {\n      var buffer = record.buffer,\n          subs = record.subs;\n      subs.unsubscribe();\n      arrRemove_1.arrRemove(bufferRecords, record);\n      subscriber.next(buffer);\n      restartOnEmit && startBuffer();\n    };\n\n    var startBuffer = function () {\n      if (bufferRecords) {\n        var subs = new Subscription_1.Subscription();\n        subscriber.add(subs);\n        var buffer = [];\n        var record_1 = {\n          buffer: buffer,\n          subs: subs\n        };\n        bufferRecords.push(record_1);\n        executeSchedule_1.executeSchedule(subs, scheduler, function () {\n          return emit(record_1);\n        }, bufferTimeSpan);\n      }\n    };\n\n    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {\n      executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);\n    } else {\n      restartOnEmit = true;\n    }\n\n    startBuffer();\n    var bufferTimeSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function (value) {\n      var e_1, _a;\n\n      var recordsCopy = bufferRecords.slice();\n\n      try {\n        for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {\n          var record = recordsCopy_1_1.value;\n          var buffer = record.buffer;\n          buffer.push(value);\n          maxBufferSize <= buffer.length && emit(record);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a = recordsCopy_1.return)) _a.call(recordsCopy_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }, function () {\n      while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {\n        subscriber.next(bufferRecords.shift().buffer);\n      }\n\n      bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();\n      subscriber.complete();\n      subscriber.unsubscribe();\n    }, undefined, function () {\n      return bufferRecords = null;\n    });\n    source.subscribe(bufferTimeSubscriber);\n  });\n}\n\nexports.bufferTime = bufferTime;","map":{"version":3,"sources":["../../../../src/internal/operators/bufferTime.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bufferTime = void 0;\nvar Subscription_1 = require(\"../Subscription\");\nvar lift_1 = require(\"../util/lift\");\nvar OperatorSubscriber_1 = require(\"./OperatorSubscriber\");\nvar arrRemove_1 = require(\"../util/arrRemove\");\nvar async_1 = require(\"../scheduler/async\");\nvar args_1 = require(\"../util/args\");\nvar executeSchedule_1 = require(\"../util/executeSchedule\");\nfunction bufferTime(bufferTimeSpan) {\n    var _a, _b;\n    var otherArgs = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        otherArgs[_i - 1] = arguments[_i];\n    }\n    var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;\n    var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;\n    var maxBufferSize = otherArgs[1] || Infinity;\n    return lift_1.operate(function (source, subscriber) {\n        var bufferRecords = [];\n        var restartOnEmit = false;\n        var emit = function (record) {\n            var buffer = record.buffer, subs = record.subs;\n            subs.unsubscribe();\n            arrRemove_1.arrRemove(bufferRecords, record);\n            subscriber.next(buffer);\n            restartOnEmit && startBuffer();\n        };\n        var startBuffer = function () {\n            if (bufferRecords) {\n                var subs = new Subscription_1.Subscription();\n                subscriber.add(subs);\n                var buffer = [];\n                var record_1 = {\n                    buffer: buffer,\n                    subs: subs,\n                };\n                bufferRecords.push(record_1);\n                executeSchedule_1.executeSchedule(subs, scheduler, function () { return emit(record_1); }, bufferTimeSpan);\n            }\n        };\n        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {\n            executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);\n        }\n        else {\n            restartOnEmit = true;\n        }\n        startBuffer();\n        var bufferTimeSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function (value) {\n            var e_1, _a;\n            var recordsCopy = bufferRecords.slice();\n            try {\n                for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {\n                    var record = recordsCopy_1_1.value;\n                    var buffer = record.buffer;\n                    buffer.push(value);\n                    maxBufferSize <= buffer.length && emit(record);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a = recordsCopy_1.return)) _a.call(recordsCopy_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }, function () {\n            while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {\n                subscriber.next(bufferRecords.shift().buffer);\n            }\n            bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();\n            subscriber.complete();\n            subscriber.unsubscribe();\n        }, undefined, function () { return (bufferRecords = null); });\n        source.subscribe(bufferTimeSubscriber);\n    });\n}\nexports.bufferTime = bufferTime;\n//# sourceMappingURL=bufferTime.js.map"]},"metadata":{},"sourceType":"script"}